## 七种查找算法
**查找定义：** 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素(或记录)。<br/>
**平均查找长度(Average Search Length, ASL):** 需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。<br/>
对于含有n个数据元素的查找表，查找成功的平均查找长度为:ASL =P(i)* C(i)的和。<br/>
    * P(i):查找表中第i个数据元素的概率。
    * C(i):找到第i个数据元素时已经比较过的次数
### 1.顺序查找
**说明:** 顺序查找适合于存储结构为顺序存储或链接存储的线性表。<br/>

**基本思想:** 顺序查找也称为线性查找，属于无序查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。<br/>

**复杂度分析：**
* 查找成功时平均查找长度为:(假设每个数据元素的概率相等)ASL = 1/n(1+2+3+...+n) = (n+1)/2;
* 查找不成功时，需要n+1次比较，时间复杂度为O(n);

所以，**顺序查找的时间复杂度为O(n)。**<br/>

**Java实现源码**
```
  //顺序查找
  int SequenceSearch(int a[], int value, int n){
    int i;
    for(i=0; i<n; i++){
      if(a[i]==value)
        return i;
    }
    return -1;
  }
```

### 2.二分查找
**说明:** 元素必须是有序的，如果是无序的则要先进行排序操作。<br/>

**基本思想:** 也称为折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线性表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。<br/>

**复杂度分析:** 最坏情况下，关键词比较次数log_2_(n+1)，且期望时间复杂度为O(log_2_n)<br/>

**注意:** 折半查找的前提条件是需要有序表顺序存储。对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

**Java实现源码**
```
  //二分查找(折半查找)，版本1
  int BinarySearch1(int a[], int value, int n){
    int low, high, mid;
    low = 0;
    high = n-1;
    while(low<=high){
      mid = (low+high)/2;
      if(a[mid]==value)
        return mid;
      if(a[mid]>value)
        high=mid-1;
      if(a[mid]<value)
        low=mid+1;
    }
    return -1;
  }

  //二分查找，递归版本
  int BinarySearch2(int a[], int value, int low, int high){
    int mid = low + (high-low)/2;
    if(a[mid]==value)
      return mid;
    if(a[mid]>value)
      return BinarySearch2(a, value, low, mid-1);
    if(a[mid]<value)
      return BinarySearch2(a, value, mid+1, high);
  }
```

### 3.插值查找
**说明:** 折半查找这种查找方式，不是自适应。二分查找中查找点计算如下:
```
   mid=(low+high)/2, 即mid=low+(high-low)/2;
```
通过类比，我们可以将查找的点改进为如下:
```
  mid=low+(key-a[low])/(a[high]-a[low])*(high-low)
```
也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值得变化更靠近关键字key，这样也就间接地减少了比较次数。<br/>

**基本思想:** 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。<br/>

**复杂度分析:** 查找成功或者失败的时间复杂度均为O(log_2_(log_2_n))

**注意:** 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

**Java实现源码**
```
  //插值查找
  int InsertionSearch(int a[], int value, int low, int high){
    int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);
    if(a[mid]==value)
        return mid;
    if(a[mid]>value)
        return InsertionSearch(a, value, low, mid-1);
    if(a[mid]<value)
        return InsertionSearch(a, value, mid+1, high);
  }
```

### 4.斐波那契额查找
**说明:** 0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。

**基本思想:** <br/>
也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。<br/>
相对于折半查找，一般将待比较的key值与第mid=(low+high)/2位置的元素比较，比较结果分三种情况:
1. 相等，mid位置的元素即为所求
2. 大于，low=mid+1
3. 小于，high=mid-1

斐波那契查找与折半查找很相似，它是根据斐波那契序列的特点对有序表进行分割的。它要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;开始将k值与第F(k-1)位置的记录进行比较(mid=low+F(k-1)-1)，比较结果也分为三种:
1. 相等，mid位置的元素即为所求
2. 大于，low=mid+1,k-=2;<br/>
  说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2说明范围[mid+1,high]内元素个数为n-F(k-1)=F(k)-1-F(k-1)=F(k-2)-1个，所以可以递归的应用斐波那契查找。
3. 小于，high=mid-1,k-=1;
  说明：high=mid-1说明待查找的元素在[low,mid-1]范围内，k-=1说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找。

**复杂度分析:** 最坏情况下，时间复杂度为O(log_2_n)，且其期望复杂度也为O(log_2_n)

**Java实现源码**


### 5.树表查找
#### 5.1 最简单的树表查找算法——二叉树查找算法
**基本思想:** 二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支，然后在和每个节点父节点比较大小，查找最适合的范围。这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。

**二叉查找树** 具有下列性质
1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根节点的值。
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根节点的值。
3. 任意节点的左、右子树也分别为二叉查找树。

**二叉查找树性质:** 对二叉查找树进行中序遍历，即可得到有序的数列。

**复杂度分析:** 它和二分查找一样，插入和查找的时间复杂度均为O(log_2_n)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

#### 5.2 平衡查找树——2-3查找树(2-3 Tree)
**2-3查找树定义:**
1. 要么为空，要么存在2个节点或者3个节点
2. 对于2节点，该节点保存一个key及对应value，以及2个指向左右节点的节点，左节点也是一个2-3节点，所有值都比key要小，右节点也是一个2-3节点，所有的值比key要大。
3. 对于3节点，该节点保存两个key及对应value，以及3个指向左中右的节点。左节点也是一个2-3节点，所有的值均比2个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在2个根节点key值之间；右节点也是一个2-3节点，节点的所有key值比2个key中的最大的key还要大。

**2-3查找树的性质**
1. 如果中序遍历2-3查找树，就可以得到排好序的序列；
2. 在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。(这也是平衡树中'平衡'一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度)

**复杂度分析**<br/>
2-3树的查找效率与树的高度是息息相关的。
* 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
* 在最好的情况下，所有的节点都是3-node节点，查找效率为log_3_N约等于0.631lgN

距离来说，对于1百万个节点的2-3树，树的高度为12-20之间；对于10亿个节点的2-3树，树的高度为18-30之间。

#### 5.3 平衡查找树——红黑树(Red-Black Tree)
**基本思想:** 红黑树的思想就是对2-3查找树进行编码，尤其是2-3查找树中的3-nodes节点添加额外的信息。红黑谁中将节点之间的连接分为两种不同类型:**红色链接** 他用来链接两个2-nodes节点来表示一个3-nodes节点；**黑色链接** 用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-nodes是另一个2-nodes的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。

**红黑树的定义:** 红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：
* 红色节点向左倾斜
* 一个节点不可能有两个红色链接
* 整个树完全黑色平衡，即从根节点到所有叶子节点的路径上，黑色链接的个数都相同。

**红黑树的性质:** 整个树完全黑色平衡，即从根节点到所有节点的路径上，黑色链接的个数都相同。

**复杂度分析:** 最坏情况就是，红黑树中除了最左侧路径全部都是由3-nodes节点组成，即红黑相间的路径长度是全黑路径长度的2倍。**红黑树的平均高度大约为logN**

#### 5.4 B树和B+树(B Tree/B+ Tree)
**B树定义:** B树可以看作是对2-3查找树的一种扩展，即它允许每个节点有m-1个子节点。
* 根节点至少有两个子节点
* 每个节点有m-1个key，并且以升序排列
* 位于m-1和m key的子节点的值位于m-1和m key对应的value之间
* 其他节点至少有m/2个子节点

**B+树定义:** B+树是对B树的一种变形树，它与B树的差异在于:
* 有k个子节点的节点必然有k个关键码
* 非叶节点仅具有索引作用，跟记录有关的信息均存放在叶节点中
* 树的所有叶节点构成一个有序链表，可以按照关键码排序的次序遍历全部记录

**B和B+树的区别** B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子节点和相连的节点使用链表相连，便于区间查找和遍历。<br/>
B+树的优点在于
* 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好地空间局部性。因此访问叶子节点上关联的数据也具有更好地缓存命中率。
* B+树的叶子节点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

B树优点：<br/>
  由于B树的每一个节点都包含key和value,因此经常访问的元素可能离根节点更近，因此访问也更迅速。

B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。

### 6.分块查找
**说明:** 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。

**基本思想:** 将n个数据元素'按块有序'划分为m块(m<=n)。每一块中的结点不必有序，但块与块之间必须'按块有序':即第1块中任一元素的关键字都必须小于第二块中任一元素的关键字,而第二块中任一元素又都必须小于第三块中的任一元素，...

### 7.哈希查找
**说明:** 哈希表的两大特点："直接定址"和"解决冲突"。哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。

**基本思想:** 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

**算法流程:**
1. 用给定的哈希函数构造哈希表
2. 根据选择的冲突处理方法解决地址冲突：拉链法和线性探测法
3. 在哈希表的基础上执行哈希查找

**复杂度分析:**
单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1);Hash是一种典型**以空间换时间**的算法。
