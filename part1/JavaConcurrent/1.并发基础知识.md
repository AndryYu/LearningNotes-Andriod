## Java并发基础知识
### 1.线程的生命周期
![线程状态转化](http://upload-images.jianshu.io/upload_images/5361549-6dd02f4652ad1253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620)
以下是线程生命周期的阶段：
* 新建状态(New): 新创建了一个线程对象。
* 就绪状态(Runnable): 线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
* 运行状态(Running): 就绪状态的线程获取了CPU，执行程序代码。
* 阻塞状态(Blocked): 阻塞状态是线程因为某个原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种:
  1. 等待阻塞(Waiting): 运行的线程执行wait()方法，JVM会把该线程放入等待池中。
  2. 同步阻塞(Blocked): 运行的线程在获取对象的同步锁时，若该同步锁被别的线程占有，则JVM会把该线程放入锁池中。
  3. 超时阻塞(Time_Waiting): 运行的线程执行sleep(long)或join(long)方法，或者发出了I/O请求是，JVM会把该线程置为阻塞状态。
* 死亡状态(Dead): 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

### 2.线程的创建
#### 通过实现Runnable接口创建一个线程


#### 通过扩展Thread类创建一个线程



### 3.线程的优先级
每个Java线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。Java线程优先级在MIN_PRIORITY(常数为1)和MAX_PRIORITY(常数为10)之间的范围内。默认情况下，每个线程都被赋予优先级NORM_PRIORITY(常数为5)。

### 4.线程的主要操作
核心Java提供对多线程程序的完全控制。也可以开发一个可以根据您的要求完全暂停、恢复或停止的多线程程序。有各种静态方法可以用于线程对象来控制它们的行为。下表列出了这些方法

编号 | 方法 | 说明描述
-|:-|:-
1 | public void sleep()| 进入阻塞状态，不会释放对象的锁
2 | public void join() | 主线程等待子线程完成，再往下执行
3 | public void interrupt() | 向被调用的对象线程发起中断请求
4 | public boolean isInterrupted() | 判断是否有中断发生
5 | public boolean Interrupted() |该方法不但可以判断当前线程是否被中断，还会清除线程内部的中断标记
6 | public void yield() |尝试让出所占有的CPU资源，让其他线程获取运行机会，对操作系统上的调度器来说是一个信号，不一定立即切换线程。

### 5.共享变量
在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看一下这三者概念：
1. 原子性  即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
2. 可见性 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3. 程序执行的顺序按照代码的先后顺序执行。

#### 5.1 volatile关键字
一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：
1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序

volatile关键字禁止指令重排序有两层意思：
1. 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。
2. 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

**volatile的原理和实现机制**<br/>
观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令实际上相当于一个内存屏障(也称为内存栅栏)，内存屏障会提供三个功能：
1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。
2. 它会强制将对缓存的修改操作立即写入主存。
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。

**使用volatile关键字的场景**<br/>
synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替换synchronized关键字的，因为volatile关键字无法保证操作的原子性，通常来说，使用volatile必须具备以下2个条件：
1. 对变量的写操作不依赖于当前值
2. 该变量没有包含在具有其他变量的不变式中

#### 5.2 final关键词


#### 5.3 java基本类型的原子操作
