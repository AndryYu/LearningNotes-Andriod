## NDK双守护进程（一）
### 进程结构
Linux下一个进程在内存里有三个部分的数据，就是"代码段"、"堆栈段"和"数据段"。
* "代码段"：就是存放了程序代码的数据，如果机器中有数个进程运行相同的一个程序，那么它们就可以使用相同的代码段。
* "堆栈段"：存放的是子程序的返回地址、子程序的参数以及程序的局部变量。
* "数据段"：存放的是程序的全局变量、常数以及动态数据分配的数据空间(比如用malloc之类的函数取得的空间)。

有两个基本的操作用于创建和修改进程：
* 函数```fork()```用来创建一个新的进程，该进程几乎是当前进程的一个完全拷贝，利用了父进程的代码段、堆栈段和数据段。当父子进程中对共有的数据段进行重新设定或调用不同方法时，才会导致数据段及堆栈段的不同。
* 函数族```exec()```用来启动另外的进程以取代当前运行的进程，除了PID仍是原来的值外，代码段、堆栈段、数据段已经万物按被改写了。

主进程监听子进程的SIGSTOP、SIGTERM状态两个操作：
* 函数```wait()```，父进程执行了wait函数后，如果子进程已经发生了状态变化，则wait函数立即就会有返回结果；否则wait函数会一直阻塞直至子进程状态发生变化。
* 函数```sigaction()```，异步回调。


### fork函数
执行fork()函数后，会生成一个子进程。fork()执行依稀后会有两次返回值：第一次为原来的进程，即父进程会有一次返回值，表示新生成的子进程的进程ID;第二次为子进程的起始执行，返回值为0。如果返回值为-1，则表示创建子进程失败，可能通过errno定位失败原因。

**fork使用场景**<br/>
* 守护进程
  有时为了保护主进程不被杀，或者主进程意外退出后仍可再次启动(或后台运行)，就执行fork()让子进程监控主进程的运行状态，根据监听保护主进程的运行。
* 框架扩展
  主线程只负责生成子进程，派出子进程去执行应用框架下的子任务，这些任务可能多变、更新频繁，但配合fork()及exec()函数，一切都很简单，还保证了主进程的稳定，避免频繁更新程序。


### sigaction函数



### pipe函数
**定义函数**
```
int pipe(int filedes[2]);
```
**函数说明**<br/>
pip()会建立管道，并将文件描述符由参数filedes数组返回。filedes[0]为管道里的读取端，filedes[1]则为管道的写入端。<br/>
若成功返回零，否则返回-1，错误原因存于errno中。

### strcmp函数
**定义函数**
```
int strcmp(const char* s1, const char* s2);
```
**函数说明**<br/>
比较字符串s1和s2，即：两个字符串自左向右逐个字符相比(按ASCII值大小相比较)，直到出现不同的字符或遇'\0'为止。<br/>
返回值：当s1<s2时，返回值<0;当s1=s2时，返回值=0；当s1>s2时，返回值>0.


### atoi函数
**定义函数**
```
int atoi(const char* str);
```
**函数说明**<br/>
把字符串转换成整型数。每个函数返回int值，此值由将输入字符作为数字解析而生成。如果该输入无法转换为该类型的值，则atoi的返回值为0；

### kill函数
**定义函数**
```
int kill(pid_t pid, int sig);
```
**函数说明**<br/>
kill()可以用来送参数sig指定的信号给参数pid指定的进程。执行成功则返回0，如果有错误则返回-1；

### flock函数
**定义函数**
```
int flock(int fd, int operation);
```
**函数说明**<br/>
flock函数会依参数operation所指定的方式对参数fd锁指定的文件做各种锁定或解除锁定的动作。此函数只能锁定整个文件，无法锁定文件的某一区域。<br/>
参数operation有下列四中情况：
* LOCK_SH 建立共享锁定。多个进程可同时对同一个文件做共享锁定。
* LOCK_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。
* LOCK_UN 解除文件锁定状态。
* LOCK_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK_SH或LOCK_EX做OR(|)组合。
