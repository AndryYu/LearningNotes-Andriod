## Android安全模型
这一章首先简要介绍Android的体系结构、进程间通信(IPC)机制和一些主要组件。然后介绍Android安全模型，以及它与底层Linux安全基础设施和代码签名机制之间的关联关系。最后讲述Android安全模型新增的特性，其中包括多用户支持、基于SELinux的强制访问控制(MAC)、验证启动模式。

### Android体系结构
![image.png](https://upload-images.jianshu.io/upload_images/5361549-f98e2927d8c2a567.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### Linux内核层
Android建立在Linux内核层上，内核层提供硬件驱动、网络、文件系统访问控制与进程管理功能。Android内核与‘标准’Linux内核版本还有一些细微的区别，他们之间的区别主要是由于支持Android而增加的一些新特性(也叫作Androidism)而造成的。主要的Androidism包括低内存管理机制(low memory killer)、唤醒锁机制(wakelock，集成在linux内核的唤醒机制中)、匿名共享内存(ashmem)、闹铃、网络访问控制机制(paranoid networking)级Binder机制等。

#### Dalvik虚拟机
Dalvik的设计考虑到了移动终端环境，而且不能直接执行Java字节码(.class文件)：它的原生输入格式是Dalvik可执行文件(DEX),并且打包成.dex文件。Dalvik是基于寄存器的，而JVM是基于栈的，其指令集也不相同。通常情况下，基于寄存器的虚拟机使用的指令更少，但其生成的代码要比基于栈的虚拟机多。然而，在大多数体系结构上，加载代码的开销要小于指令分发，所以基于寄存器虚拟机的解释执行效率更高。

#### Binder
虽说Binder是一种新的实现，但它还是基于OpenBinder的设计和构想而来的。Binder实现了一个基于抽象接口的分布式组件架构。<br/>

##### Binder实现
内核控制着所有进程，因此可以暴露一个接口用作IPC。在Binder中这个接口就是/dev/binder设备，该设备是由Binder内核驱动程序实现的。Binder驱动是这一框架的核心对象，所有IPC调用都通过它来实现。进程间通信是通过一个ioctl()调用实现的，它使用binder_write_read结构收发数据，该数据结构由一个write_buffer和一个read_buffer组成，其中write_buffer包含驱动所要执行的命令，而read_buffer包括用户层需要执行的命令。<br/>
**数据实际上是如何在进程间传输的呢?** Binder驱动管理每个进程的一部分地址空间。Binder驱动管理的内存块，对于进程是只读的，其写操作由内核模块来实施。当一个进程向另一个进程发送消息时，内核在目标进程的内存空间里申请一部分空间，接着直接将消息从发送进程复制进去。然后它将接收消息的具体位置，通过一个短消息发给接受进程。因为消息在接收者的内存空间，接收者可以直接访问到消息。当进程不再需要这个消息时，它通知Binder驱动程序来释放这一块内存。

#### Android框架库
尽管几乎所有Android内核层以上的操作系统功能均被实现为系统服务，但它不直接暴露给framework，而是通过叫做managers的外部封装类进行访问。

#### 应用程序
* 系统应用<br/>
Android 4.4版本以后，安装在/system/priv-app/下的被认为是特权应用，只对这些应用赋予signatureOrSystem保护级别的权限，而不是所有/system下的应用，使用平台签名密钥签发的应用可被赋予signature保护级别的系统权限，因此即使它们是非预装在/system下的，也可以获取OS级别的权限。
* 用户自安装应用<br/>
用户自安装应用存放在一个专用的，具有读写权限的分区(通常挂载为/data目录)，可以随意卸载。每个应用使用一个专有的安全沙箱，通常不会影响到其他应用或者访问其他应用的数据。

### Android的安全模型介绍
Android安全模型同样利用了Linux内核提供的安全特性。Linux是一个多用户的操作系统，内核可以把用户资源相互隔离，就像它隔离进程一样。<br/>
Android利用了这个用户隔离机制，但与传统的桌面或服务器版的Linux系统有所不同。在传统Linux系统中，一个UID可以给登录系统并通过shell执行命令的物理用户，也可以给在后台执行的系统服务。Android本来是为智能手机设计的，由于智能手机是私人设备，所以不需要在系统内注册不同的物理用户，物理用户是隐式的，所以UID被用来区别应用程序。
#### 应用程序沙箱
在每个应用程序的安装阶段，Android自动为每个应用赋予一个独一无二的UID，通常称作appID，应用执行时就在特定进程内以该UID运行。另外，每个应用都有一个只有它具有读写权限的专用数据目录。因此，应用程序是隔离的，或沙箱封装化的，包括进程级和文件级。<br/>
系统服务的UID从1000开始，1000是system用户(AID_SYSTEM)，具有特殊的权限(但仍然是受限的)。对于应用程序，自动从10000(AID_APP)开始产生UID，对应的用户名是app_XXX或uY_aXXX(支持多用户的android版本)的格式，XXX即是从AID_APP起的偏移，Y是Android的user ID(与UID不同)。<br/>
应用程序UID和包的其他元数据一起由/data/system/packages.xml文件管理，同时被写入/data/system/packages.list文件。应用程序可以使用同一个UID安装，叫做共享用户ID(通过在AndroidManifest.xml里面配置相同的sharedUserId)，在这种情况下，它们共享文件，甚至在同一个进程中运行。为共享同一个UID，应用需要使用同一个密钥进行代码签名。

#### 权限
因为Android应用是沙箱隔离的，它们只能访问自己的文件和一些设备上全局可访问的资源。然而这样一个受限的应用并不好玩，但Android可以赋予应用额外的、更细粒度的访问权限，从而使应用具备更丰富的功能。这些访问权限称为permission，它们可以控制硬件设备、网络连接、数据或OS服务的访问。<br/>
应用程序通过在AndroidManifest.xml文件中进行定义，来请求访问权限。在应用程序安装时，Android检查请求权限列表，从而决定是否给予授权。

#### IPC



#### 代码签名和平台密钥
因为Android APk文件是Java JAR包格式的扩展，所使用的代码签名方法也是基于JAR签名。Android使用APK签名来确保应用更新包是来自于同一个作者(称作同源策略)，从而建立应用程序之间的信任关系。系统应用是用一些平台密钥(platform key)签名的。不同的系统组件之间可以共享资源，并且当他们被相同平台密钥签名时，可以在同一个进程中运行。

#### 多用户支持
每个用户都有唯一的user ID，该ID从0开始生成，并且每个用户都有自己的数据目录/data/system/users/<user ID>/，这也叫作用户的系统目录。

#### SELinux
* 自主访问控制(DAC)：表示一旦用户获得某一资源的访问控制权限，那么用户可根据自己的意愿，将该资源传递给其他用户，比如设置某个文件的访问控制位为全局可读。
* 强制访问控制(MAC):它确保对资源的访问控制，符合一个系统范围的授权规则，该规则也叫作策略。

SELinux是一个面向Linux内核的强制访问控制(MAC)机制实现，并且在10年前就已经集成到主线内核中了。Android 4.4版本及其之后，SELinux以 **强制模式(enforcing mode)** 部署，违反系统策略将会产生运行时错误，但强制策略只应用于核心系统守护进程。应用程序仍旧运行在 **宽容模式(permissive mode)** ,违反策略只会被记录进日志，而不会产生运行时错误。

#### 系统更新
Android设备可以OTA更新，也可以连接至PC，并使用ADB将更新镜像推送到手机，还可以使用手机供应商提供的应用实现系统更新功能。OTA更新是通过下载一个OTA包文件(通常是一个有代码签名的zip文件)，该文件中包括一个可被recovery解释执行的小脚本文件，通过重启设备到recovery模式来执行更新动作。

#### 验证启动模式
Android 4.4版本使用对Linux设备映射器的真实靶，支持了验证启动。验证模块使用哈希树来提供透明的块设备完整性检查。哈希树上的每个节点是一个哈希值，其中叶子节点存放的是物理数据块的哈希值，而中间节点存放的是子节点的哈希值。因根节点的值基于所有其他节点，所以只要根节点的哈希值是受信任的，那么也就验证了该树的其他部分。<br/>
验证过程使用包含在引导分区的RSA公钥。设备块在运行时被检查，方法是计算读到块的哈希值，并与哈希树上的记录值做比较。如果不匹配，那么读操作会导致一个I/O错误，表示文件系统出了问题。因为所有的检查都是内核执行的，引导进程需要先验证内核的完整性，验证启动模式方可工作。而这个进程是设备相关的，通常使用不可改变的、硬件相关的密钥，‘烧录’到设备中。这个密钥即用来验证每级引导加载程序的完整性，并最终验证内核的完整性。
