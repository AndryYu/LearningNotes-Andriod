## Jvm、Dalvik以及ART的区别

#### 概念
**什么是Dalvik**
<p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。dex格式是专为Dalvik应用设计的一种压缩格式，适用于内存和处理器速度有限的系统。Dalvik允许同时运行多个虚拟机的实例，并且每一个应用作为独立的Linux进程执行。独立地进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p>

**什么是ART**
<p>在Dalvik下，应用每次运行都需要通过即时编译器(JIT)将字节码转换为机器码，即每次都要编译加运行，这一机制并不高效,但让应用安装比较快，而且更容易在不同硬件和架构上运行。</p>
<p>ART完全改变了这种做法，在应用安装时就预编译字节码到机器语言，在移除解释代码这一过程后，应用程序执行将更有效率，启动更快</p>


#### Dalvik vs Jvm
**共同点**<br/>
* 都是解释执行
* 都是每个OS进程运行一个VM，并运行一个单独的程序
* 在较新版本中都实现了相当程度的JIT compiler(即时编译)用于提速

注：JIT（Just In Time，即时编译技术）对于热代码（使用频率高的字节码）直接转换成汇编代码；

**不同点**<br/>
* dvm执行的是.dex格式文件，jvm执行的是.class文件。<br/>
class文件和dex之间可以相互转换具体流程如下图，多个class文件转变成一个dex文件会引发一些问题，具体如下：
  1. 方法数受限：多个class文件变成一个dex文件所带来的问题就是方法数超过65535时报错，由此引出MultiDex技术，具体资料同学可以google下。
  2. class文件去冗余：class文件存在很多的冗余信息，dex工具会去除冗余信息(多个class中的字符串常量合并为一个，比如对于Ljava/lang/Oject字符常量，每个class文件基本都有该字符常量，存在很大的冗余)，并把所有的.class文件整合到.dex文件中。减少了I/O操作，提高了类的查找速度。
* 许多GC实现都是在对象开头的地方留一小块空间给GC标记用。Dalvik VM则不同，在进行GC的时候会单独申请一块空间，以位图的形式来保存整个堆上的对象的标记，在GC结束后就释放该空间。
* dvm是基于寄存器的虚拟机 而jvm执行是基于虚拟栈的虚拟机。
这类的不同是最要命的，因为它将导致一系列的问题，具体如下：
  1. dvm速度快！寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。JAVA虚拟机基于栈结构，程序在运行时虚拟机需要频繁的从栈上读取写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费很多CPU时间。
  2. 指令数小！dvm基于寄存器，所以它的指令是二地址和三地址混合，指令中指明了操作数的地址；jvm基于栈，它的指令是零地址，指令的操作数对象默认是操作数栈中的几个位置。这样带来的结果就是dvm的指令数相对于jvm的指令数会小很多，jvm需要多条指令而dvm可能只需要一条指令。
  3. jvm基于栈带来的好处是可以做的足够简单，真正的跨平台，保证在低硬件条件下能够正常运行。而dvm操作平台一般指明是ARM系统，所以采取的策略有所不同。需要注意的是dvm基于寄存器，但是这也是个映射关系，如果硬件没有足够的寄存器，dvm将多出来的寄存器映射到内存中。

#### Dalvik vs ART
1. 在Dalvik下，应用每次运行都需要通过即时编译器（JIT）将字节码转换为机器码，即每次都要编译加运行，这虽然会使安装过程比较快，但是会拖慢应用以后每次启动的效率。而在ART 环境中，应用在第一次安装的时候，字节码就会预编译（AOT）成机器码，这样的话，虽然设备和应用的首次启动（安装慢了）会变慢，但是以后每次启动执行的时候，都可以直接运行，因此运行效率会提高。
2. ART占用空间比Dalvik大（字节码变为机器码之后，可能会增加10%-20%），这也是著名的“空间换时间大法"。
3. 预编译也可以明显改善电池续航，因为应用程序每次运行时不用重复编译了，从而减少了 CPU 的使用频率，降低了能耗
