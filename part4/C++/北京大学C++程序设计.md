# C++程序设计

## 函数指针
* 基本概念
  程序运行期间，每个函数都会占用一段连续的内存空间。而函数名就是该函数所占内存区域的起始地址(也称“入口地址”)。我们可以将函数的入口地址赋给一个指针变量，使该指针变量指向该函数。然后通过指针变量就可以调用这个函数。这种指向函数的指针变量为"函数指针"。
* 定义形式
  类型名(* 指针变量名)(参数类型1，参数类型2 ..)
* 使用方法
  可以用一个原型匹配的函数的名字给一个函数指针赋值，再通过函数指针调用它所指向的函数，写法为：**函数指针名(实参表)**

## 命令行参数

  例子： notepad sample.txt

```
  int main(int argc, char *argv[]){
    ... ...
  }
```
* argc:代表启动程序时，命令行参数的个数。C/C++语言规定，可执行程序本身的文件名，也算一个命令行参数，因此，argc的值至少是1.
* argv:指针数组，其中的每个元素都是一个char* 类型的指针，该指针指向一个字符串，这个字符串里就存放着命令行参数。<br/>
  例如：argv[0]指向的字符串就是第一个命令行参数，即可执行程序的文件名，argv[1]指向第二个命令行参数，argv[2]指向第三个命令行参数......

## 位运算
1. 按位与“&”<br/>
  将参与运算的两操作数各对应的二进制位进行与操作。只有对应的两个二进位均为1时，结果的对应二进制位才为1，否则为0。<br/>
  通常用来将某变量中某些位清0且同时保留其他位不变，也可以用来获取某变量中的某一位。
2. 按位或“|”<br/>
  按位或运算通常用来将某变量中的某些位置1且保留其他位不变。
3. 按位异或“^”<br/>
  只有对应的两个二进位不相同时，结果对应二进制位才是1，否则为0。
  按位异或运算通常用来将某变量中的某些位取反，且保留其他位不变。<br/>
  异或运算的特点：
  如果a^b=c,那么就有c^b=a以及c^a=b。此规律可以用来进行最简单的加密和解密。
4. 按位非“~”<br/>
  将操作数中的二进制位0变成1,1变成0。
5. 左移运算符“<<”<br/>
  高位丢弃，低位补0。实际上，左移1位，就等于乘以2，左移n位，相当于乘以2^n。
6. 右移运算符“>>”<br/>
  右移时，移出最右边的位就被丢弃；符号位(即最高位)将一起移动，并且大多数C/C++编译器规定，如果原符号位为1，则右移时高位就补充1，原符号位为0，则右移时高位就补充0。无符号数，高位补0。<br/>
  实际上，右移n位，就相当于左操作数除以2^n,并且将结果往小里取整。


## 引用
类型名 & 引用名 = 某变量名。
* 定义引用时一定要将其初始化成引用某个变量。
* 初始化后，它就一直引用该变量，不会再引用别的变量了。
* 引用只能引用变量，不能引用常量和表达式。

## 常引用
定义引用时，前面加const关键字，即为“常引用”。

## const常用语法
1. 定义常量
2. 定义常量指针
  * 不可通过常量指针修改其指向的内容
  * 不能把常量指针赋值给非常量指针，反过来可以
  * 函数参数为常量指针时，可避免函数内部不小心改变参数指针所指地方的内容
3. 定义常引用

## 动态内存分配
1. 用new运算符实现动态内存分配
  * 第一种用法，分配一个变量<br/>
  P = new T;
  T是任意类型名，P是类型为T* 的指针。
  动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P.
  * 第二种用法，分配一个数组<br/>
  P = new T[N];
  T:任意类型名，P:类型为T* 的指针，N:要分配的数组元素的个数，可以是整形表达式
2. 用delete运算符释放动态分配的内存<br/>
  * delete 指针<br/>
  指针必须指向new出来的空间，一片空间不能被delete多次
  * delete [] 指针<br/>
  该指针必须指向new出来的数组

## 内联函数
编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。在函数定义前面加“inline”关键字，即可定义内联函数。

## 函数重载
一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载。

## 函数的缺省参数
在C++中，定义函数的时候，可以让**最右边**的连续若干个参数有缺省值，那么调用函数的时候，若相应位置不写参数，参数就是缺省值。

## 面向对象程序设计方法
## 面向对象语言的发展历程

## 类成员的可访问范围
* private
* public
* protected

## 内联成员函数与重载成员函数
* 内联成员函数


* 重载成员函数


## 构造函数




## 复制构造函数
* 只有一个参数，即对同类对象的引用。形如X::X(X&)或X::X(const X &)，二者选一，后者能以常量对象作为参数
* 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。

```
  class Complex{
    private:
        double real, imag;
  };
  Complex cl; //调用缺省无参构造函数
  Complex c2(c1); //调用缺省的复制构造函数，将C2初始化成和c1一样
```
复制函数起作用的三种情况：
1. 当用一个对象去初始化同类的另一个对象时
2. 如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。
3. 如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。

## 类型转换构造函数
特点：
* 只有一个参数
* 不是复制构造函数

## 析构函数
成员函数的一种：
* 名字和类名相同
* 在前面加'~'
* 没有参数和返回值
* 一个类最多只有一个析构函数

对象消亡时自动被调用。

## 静态成员变量和静态成员函数
静态成员：在说明前面加了static关键字的成员。<br/>
基本概念：
1. 普通成员变量每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。*sizeof运算符不会计算静态成员变量*
2. 普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。

如何访问静态成员
1. 类名：：成员名
2. 对象名.成员名
3. 指针->成员名
4. 引用.成员名

## 成员对象和封闭类的概念
成员对象：一个类的成员变量是另一个类的对象

封闭类构造函数的初始化列表
* 定义封闭类的构造函数时，添加初始化列表：
  ```
    类名::构造函数(参数表):成员变量1(参数表)，成员参数2(参数表),...
    {
      ...
    }
  ```
* 成员对象初始化列表中的参数
  * 任意复杂的表达式
  * 函数/变量/表达式中的函数，变量有定义

调用顺序：
* 当封闭类生成时
  * S1：执行所有成员对象的构造函数
  * S2：执行封闭类的构造函数
* 成员对象的构造函数调用顺序
  * 和成员对象在类中的说明顺序一致
  * 与在成员初始化列表中出现的顺序无关
* 当封闭类的对象消亡时
  * S1：先执行封闭类的析构函数
  * S2：执行成员对象的析构函数

## 友元
友元函数(friend)
* 一个类的友元函数可以访问该类的私有成员
* 将一个类的成员函数(包括构造、析构函数)定义成另一个类的友元

友元类
* 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。(友元类不能继承和传递)

## this指针
作用：
* 指向成员函数所作用的对象


## 常量对象、常量成员函数和常引用
常量对象
* 如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字。

常量成员函数
* 在类的成员函数说明后面可以加const关键字，则该成员函数成为常量成员函数。
* 常量成员函数执行期间不应修改对象的数据
* 两个成员函数，名字和参数表都一样，但是一个是const，一个不是，算重载

常引用
* 引用前面可以加const关键字，成为常引用。不能通过常引用，修改其引用的变量

## 运算符重载
* 对已有的运算符赋予多重的含义
* 使同一运算符作用于不同的类型的数据时，表现不同类型的行为

目的：
* 扩展C++中提供的运算符的适用范围，以用于类所表示的抽象数据类型

运算符重载的实质是函数重载
```
  返回值类型 operator 运算符(形参表){
    ......
  }

```

重载的两种形式：
1. 普通函数
2. 成员函数

## 赋值运算符重载
赋值运算符“=”只能重载为**成员函数**
* 深复制/浅拷贝
* 深复制/深拷贝
  将一个对象中指针变量指向的内容变成另一个对象指针变量指向的内容

## 运算符重载为友元函数
重载为友元

## 实例一长度可变的整形数组类



## 流插入运算符和流提取运算符的重载
* ostream
* iostream

## 自增自减运算符的重载


## 继承和派生
在派生类对象中，包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。

## 复合关系和继承关系
复合关系:has

继承关系：is

## 基类派生类同名成员和protected访问范围说明符
* 基类的private成员：可以被下列函数访问
  * 基类的成员函数
  * 基类的友元函数
* 基类的public成员，可以被下列函数访问
  * 基类的成员函数
  * 基类的友元函数
  * 派生类的成员函数
  * 派生类的友元函数
  * 其他函数
* 基类的protected成员，可以被下列函数访问
  * 基类的成员函数
  * 基类的友元函数
  * 派生类的成员函数可以访问当前对象的基类的保护成员

## 派生类的构造函数
派生类对象包含基类对象<br/>
执行派生类构造函数之前，先执行基类的构造函数。<br/>
派生类交代基类初始化，具体形式
```
 构造函数名(形参表)：基类名(基类构造函数实参表){

 }
```

## public继承的赋值兼容规则
```
  class base {};
  class derived:public base{};
  base b；
  derived d；
```
1. 派生类的对象可以赋值给基类对象
   b = d;
2. 派生类对象可以初始化基类引用
   base & br = d;
3. 派生类对象的地址可以赋值给基类指针<br/>
   base * pb = &d;
如果派生方式是private或protected,则上述三条不可行。

## 虚函数和多态
在类的定义中，前面有virtual关键字的成员函数就是虚函数。

#### 多态的变现形式一
* 派生类的指针可以赋给基类指针
* 通过基类指针调用基类和派生类的同名虚函数时：
  1. 若该指针指向一个基类的对象，那么被调用是基类的虚函数；
  2. 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。
这种机制就叫做“多态”。

#### 多态的变现形式二
* 派生类的指针可以赋给基类指针
* 通过基类指针调用基类和派生类的同名虚函数时：
  1. 若该指针指向一个基类的对象，那么被调用是基类的虚函数；
  2. 若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。
这种机制就叫做“多态”。

## 使用多态的游戏实例



## 更多多态程序实例




## 多态实现原理




## 虚析构函数




## 纯虚函数和抽象类








## 文件操作









## 函数模板







## 类模板


## String类









## 输入输出
